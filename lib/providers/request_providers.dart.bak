// ========================================
// Request Providers
// Manage Overseerr/Jellyseerr media requests
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:arr/services/api/overseerr_api_service.dart';
import 'package:arr/providers/service_providers.dart';

// Request Model

class MediaRequest {
  final int id;
  final String mediaType; // 'movie' or 'tv'
  final int mediaId;
  final String? title;
  final String? posterUrl;
  final String? backdropUrl;
  final String? status; // pending, approved, declined, available
  final DateTime? createdAt;
  final DateTime? updatedAt;
  final String? requestedBy;
  final int? userId;
  final bool? is4k;
  final List<int>? seasons; // For TV shows

  MediaRequest({
    required this.id,
    required this.mediaType,
    required this.mediaId,
    this.title,
    this.posterUrl,
    this.backdropUrl,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.requestedBy,
    this.userId,
    this.is4k,
    this.seasons,
  });

  /// Check if request is pending
  bool get isPending => status == 'pending';

  /// Check if request is approved
  bool get isApproved => status == 'approved' || status == 'processing';

  /// Check if request is declined
  bool get isDeclined => status == 'declined';

  /// Check if request is available
  bool get isAvailable => status == 'available';

  /// Check if request is for TV show
  bool get isTv => mediaType == 'tv';

  /// Check if request is for movie
  bool get isMovie => mediaType == 'movie';

  MediaRequest copyWith({
    int? id,
    String? mediaType,
    int? mediaId,
    String? title,
    String? posterUrl,
    String? backdropUrl,
    String? status,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? requestedBy,
    int? userId,
    bool? is4k,
    List<int>? seasons,
  }) {
    return MediaRequest(
      id: id ?? this.id,
      mediaType: mediaType ?? this.mediaType,
      mediaId: mediaId ?? this.mediaId,
      title: title ?? this.title,
      posterUrl: posterUrl ?? this.posterUrl,
      backdropUrl: backdropUrl ?? this.backdropUrl,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      requestedBy: requestedBy ?? this.requestedBy,
      userId: userId ?? this.userId,
      is4k: is4k ?? this.is4k,
      seasons: seasons ?? this.seasons,
    );
  }

  factory MediaRequest.fromJson(Map<String, dynamic> json) {
    final media = json['media'] as Map<String, dynamic>?;
    return MediaRequest(
      id: json['id'] as int,
      mediaType: json['type'] as String? ?? 'movie',
      mediaId: media?['tmdbId'] as int? ?? json['mediaId'] as int? ?? 0,
      title: media?['title'] as String? ??
          media?['originalTitle'] as String? ??
          json['title'] as String?,
      posterUrl: media?['posterPath'] as String?,
      backdropUrl: media?['backdropPath'] as String?,
      status: json['status'] as String?,
      createdAt: json['createdAt'] != null
          ? DateTime.tryParse(json['createdAt'] as String)
          : null,
      updatedAt: json['updatedAt'] != null
          ? DateTime.tryParse(json['updatedAt'] as String)
          : null,
      requestedBy: json['requestedBy']?['displayName'] as String?,
      userId: json['requestedBy']?['id'] as int?,
      is4k: json['is4k'] as bool?,
      seasons: (json['seasons'] as List<dynamic>?)
          ?.map((e) => e as int)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': mediaType,
      'mediaId': mediaId,
      'title': title,
      'posterUrl': posterUrl,
      'backdropUrl': backdropUrl,
      'status': status,
      'createdAt': createdAt?.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
      'requestedBy': requestedBy,
      'userId': userId,
      'is4k': is4k,
      'seasons': seasons,
    };
  }
}

// Requests State

class RequestsState {
  final List<MediaRequest> requests;
  final bool isLoading;
  final String? error;
  final int? currentPage;
  final int? totalPages;
  final DateTime? lastUpdated;

  RequestsState({
    this.requests = const [],
    this.isLoading = false,
    this.error,
    this.currentPage,
    this.totalPages,
    this.lastUpdated,
  });

  RequestsState copyWith({
    List<MediaRequest>? requests,
    bool? isLoading,
    String? error,
    int? currentPage,
    int? totalPages,
    DateTime? lastUpdated,
  }) {
    return RequestsState(
      requests: requests ?? this.requests,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      currentPage: currentPage ?? this.currentPage,
      totalPages: totalPages ?? this.totalPages,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }

  /// Get pending requests
  List<MediaRequest> get pendingRequests =>
      requests.where((r) => r.isPending).toList();

  /// Get approved requests
  List<MediaRequest> get approvedRequests =>
      requests.where((r) => r.isApproved).toList();

  /// Get available requests
  List<MediaRequest> get availableRequests =>
      requests.where((r) => r.isAvailable).toList();

  /// Get declined requests
  List<MediaRequest> get declinedRequests =>
      requests.where((r) => r.isDeclined).toList();

  /// Get movie requests
  List<MediaRequest> get movieRequests =>
      requests.where((r) => r.isMovie).toList();

  /// Get TV requests
  List<MediaRequest> get tvRequests =>
      requests.where((r) => r.isTv).toList();
}

// Requests Notifier

class RequestsNotifier extends StateNotifier<RequestsState> {
  final OverseerrApiService? _api;

  RequestsNotifier(this._api) : super(RequestsState()) {
    if (_api != null) {
      loadRequests();
    }
  }

  Future<void> loadRequests({int page = 1}) async {
    if (_api == null) {
      state = state.copyWith(
        error: 'Overseerr service not configured',
      );
      return;
    }

    try {
      state = state.copyWith(isLoading: true, error: null);

      final response = await _api!.getRequests(
        page: page,
        pageSize: 50,
      );

      final data = response.data;
      final results = data['results'] as List<dynamic>?;

      final requests = <MediaRequest>[];
      if (results != null) {
        for (final item in results) {
          if (item is Map<String, dynamic>) {
            try {
              requests.add(MediaRequest.fromJson(item));
            } catch (e) {
              print('Error parsing request: $e');
            }
          }
        }
      }

      final pages = data['pageCount'] as int?;

      state = state.copyWith(
        requests: page == 1 ? requests : [...state.requests, ...requests],
        isLoading: false,
        currentPage: page,
        totalPages: pages,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> loadMore() async {
    if (state.isLoading ||
        state.currentPage == null ||
        state.totalPages == null ||
        state.currentPage! >= state.totalPages!) {
      return;
    }

    await loadRequests(page: state.currentPage! + 1);
  }

  Future<void> refresh() async {
    await loadRequests(page: 1);
  }

  Future<void> filterByStatus(String status) async {
    if (_api == null) return;

    try {
      state = state.copyWith(isLoading: true, error: null);

      final response = await _api!.getRequests(
        page: 1,
        pageSize: 50,
        filter: status,
      );

      final data = response.data;
      final results = data['results'] as List<dynamic>?;

      final requests = <MediaRequest>[];
      if (results != null) {
        for (final item in results) {
          if (item is Map<String, dynamic>) {
            try {
              requests.add(MediaRequest.fromJson(item));
            } catch (e) {
              print('Error parsing request: $e');
            }
          }
        }
      }

      final pages = data['pageCount'] as int?;

      state = state.copyWith(
        requests: requests,
        isLoading: false,
        currentPage: 1,
        totalPages: pages,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<bool> approveRequest(int requestId, {int? serverId}) async {
    if (_api == null) return false;

    try {
      await _api!.approveRequest(requestId, serverId: serverId);
      await refresh();
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  Future<bool> declineRequest(int requestId) async {
    if (_api == null) return false;

    try {
      await _api!.declineRequest(requestId);
      await refresh();
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  Future<bool> deleteRequest(int requestId) async {
    if (_api == null) return false;

    try {
      await _api!.deleteRequest(requestId);
      await refresh();
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// Request Providers

/// Requests state provider
final requestsProvider =
    StateNotifierProvider<RequestsNotifier, RequestsState>((ref) {
  final api = ref.watch(overseerrApiServiceProvider);
  return RequestsNotifier(api);
});

/// Pending requests only
final pendingRequestsProvider = Provider<List<MediaRequest>>((ref) {
  final requestsState = ref.watch(requestsProvider);
  return requestsState.pendingRequests;
});

/// Approved requests only
final approvedRequestsProvider = Provider<List<MediaRequest>>((ref) {
  final requestsState = ref.watch(requestsProvider);
  return requestsState.approvedRequests;
});

/// Available requests only
final availableRequestsProvider = Provider<List<MediaRequest>>((ref) {
  final requestsState = ref.watch(requestsProvider);
  return requestsState.availableRequests;
});

/// Request count by status
final requestCountsProvider = Provider<RequestCounts>((ref) {
  final requestsState = ref.watch(requestsProvider);

  return RequestCounts(
    pending: requestsState.pendingRequests.length,
    approved: requestsState.approvedRequests.length,
    available: requestsState.availableRequests.length,
    declined: requestsState.declinedRequests.length,
    total: requestsState.requests.length,
  );
});

/// Request counts model
class RequestCounts {
  final int pending;
  final int approved;
  final int available;
  final int declined;
  final int total;

  RequestCounts({
    required this.pending,
    required this.approved,
    required this.available,
    required this.declined,
    required this.total,
  });
}

/// Individual request detail provider
final requestDetailProvider =
    FutureProvider.family<MediaRequest?, int>((ref, requestId) async {
  final api = ref.watch(overseerrApiServiceProvider);
  if (api == null) return null;

  try {
    final response = await api.getRequestById(requestId);
    return MediaRequest.fromJson(response.data);
  } catch (e) {
    return null;
  }
});

/// Trending media from Overseerr
final trendingMediaProvider =
    FutureProvider.autoDispose<List<MediaRequest>>((ref) async {
  final api = ref.watch(overseerrApiServiceProvider);
  if (api == null) return [];

  try {
    final response = await api.getTrending(page: 1);
    final results = response.data['results'] as List<dynamic>?;

    final media = <MediaRequest>[];
    if (results != null) {
      for (final item in results) {
        if (item is Map<String, dynamic>) {
          try {
            // Convert trending item to request-like object
            media.add(MediaRequest(
              id: item['id'] as int? ?? 0,
              mediaType: item['mediaType'] as String? ?? 'movie',
              mediaId: item['id'] as int? ?? 0,
              title: item['title'] as String?,
              posterUrl: item['posterPath'] as String?,
              backdropUrl: item['backdropPath'] as String?,
              status: 'trending',
            ));
          } catch (e) {
            print('Error parsing trending item: $e');
          }
        }
      }
    }

    return media;
  } catch (e) {
    return [];
  }
});

/// Upcoming media from Overseerr
final upcomingMediaProvider =
    FutureProvider.autoDispose<List<MediaRequest>>((ref) async {
  final api = ref.watch(overseerrApiServiceProvider);
  if (api == null) return [];

  try {
    final response = await api.getUpcoming(page: 1);
    final results = response.data['results'] as List<dynamic>?;

    final media = <MediaRequest>[];
    if (results != null) {
      for (final item in results) {
        if (item is Map<String, dynamic>) {
          try {
            media.add(MediaRequest(
              id: item['id'] as int? ?? 0,
              mediaType: item['mediaType'] as String? ?? 'movie',
              mediaId: item['id'] as int? ?? 0,
              title: item['title'] as String?,
              posterUrl: item['posterPath'] as String?,
              backdropUrl: item['backdropPath'] as String?,
              status: 'upcoming',
            ));
          } catch (e) {
            print('Error parsing upcoming item: $e');
          }
        }
      }
    }

    return media;
  } catch (e) {
    return [];
  }
});
