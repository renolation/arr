// ========================================
// Service Providers
// Provide service configuration and API service instances
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:arr/core/storage/storage_service.dart';
import 'package:arr/services/api/sonarr_api_service.dart';
import 'package:arr/services/api/radarr_api_service.dart';
import 'package:arr/services/api/overseerr_api_service.dart';
import 'package:arr/services/api/download_api_service.dart';
import 'package:arr/models/hive/enums.dart';
import 'package:arr/models/hive/service_config.dart';

// Storage Service Provider (Singleton)
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService.instance;
});

// Service Configuration Providers

/// All configured services
final servicesProvider = StateNotifierProvider<ServiceConfigsNotifier, List<ServiceConfig>>((ref) {
  final storage = ref.watch(storageServiceProvider);
  return ServiceConfigsNotifier(storage);
});

/// Notifier for managing service configurations
class ServiceConfigsNotifier extends StateNotifier<List<ServiceConfig>> {
  final StorageService _storage;

  ServiceConfigsNotifier(this._storage) : super([]) {
    _loadServices();
  }

  void _loadServices() {
    state = _storage.getAllServices();
  }

  Future<void> addService(ServiceConfig service) async {
    await _storage.addService(service);
    _loadServices();
  }

  Future<void> updateService(ServiceConfig service) async {
    await _storage.updateService(service);
    _loadServices();
  }

  Future<void> deleteService(String id) async {
    await _storage.deleteService(id);
    _loadServices();
  }

  Future<bool> testConnection(ServiceConfig service) async {
    // Implementation would use the appropriate API service
    // This is a placeholder for connection testing
    try {
      // Test connection logic here
      return true;
    } catch (e) {
      return false;
    }
  }

  ServiceConfig? getDefaultService(ServiceType type) {
    final services = _storage.getServicesByType(type);
    if (services.isEmpty) return null;
    // Return first enabled service, or first service if none enabled
    return services.firstWhere(
      (s) => s.isEnabled,
      orElse: () => services.first,
    );
  }

  List<ServiceConfig> getServicesByType(ServiceType type) {
    return _storage.getServicesByType(type);
  }
}

/// Active Sonarr service configuration
final activeSonarrConfigProvider = Provider<ServiceConfig?>((ref) {
  final notifier = ref.watch(servicesProvider.notifier);
  return notifier.getDefaultService(ServiceType.sonarr);
});

/// Active Radarr service configuration
final activeRadarrConfigProvider = Provider<ServiceConfig?>((ref) {
  final notifier = ref.watch(servicesProvider.notifier);
  return notifier.getDefaultService(ServiceType.radarr);
});

/// Active Overseerr service configuration
final activeOverseerrConfigProvider = Provider<ServiceConfig?>((ref) {
  final notifier = ref.watch(servicesProvider.notifier);
  return notifier.getDefaultService(ServiceType.overseerr);
});

/// Active download client configuration
final activeDownloadClientConfigProvider = Provider<ServiceConfig?>((ref) {
  final notifier = ref.watch(servicesProvider.notifier);
  return notifier.getDefaultService(ServiceType.downloadClient);
});

// API Service Providers

/// Sonarr API service (null if no service configured)
final sonarrApiServiceProvider = Provider<SonarrApiService?>((ref) {
  final config = ref.watch(activeSonarrConfigProvider);
  if (config == null) return null;

  // Note: API key should come from secure storage
  // For now, this is a placeholder
  return SonarrApiService(
    baseUrl: config.fullUrl,
    apiKey: '', // TODO: Get from secure storage
  );
});

/// Radarr API service (null if no service configured)
final radarrApiServiceProvider = Provider<RadarrApiService?>((ref) {
  final config = ref.watch(activeRadarrConfigProvider);
  if (config == null) return null;

  return RadarrApiService(
    baseUrl: config.fullUrl,
    apiKey: '', // TODO: Get from secure storage
  );
});

/// Overseerr API service (null if no service configured)
final overseerrApiServiceProvider = Provider<OverseerrApiService?>((ref) {
  final config = ref.watch(activeOverseerrConfigProvider);
  if (config == null) return null;

  return OverseerrApiService(
    baseUrl: config.fullUrl,
    apiKey: '', // TODO: Get from secure storage
  );
});

/// Download client API service (null if no service configured)
final downloadClientServiceProvider = Provider<DownloadApiService?>((ref) {
  final config = ref.watch(activeDownloadClientConfigProvider);
  if (config == null) return null;

  return DownloadApiService(
    baseUrl: config.fullUrl,
    apiKey: '', // TODO: Get from secure storage or credentials
    clientType: DownloadClientType.qbittorrent, // TODO: Get from config
  );
});

// Service Status Providers

/// Whether any Sonarr service is configured and enabled
final hasSonarrProvider = Provider<bool>((ref) {
  return ref.watch(activeSonarrConfigProvider) != null;
});

/// Whether any Radarr service is configured and enabled
final hasRadarrProvider = Provider<bool>((ref) {
  return ref.watch(activeRadarrConfigProvider) != null;
});

/// Whether any Overseerr service is configured and enabled
final hasOverseerrProvider = Provider<bool>((ref) {
  return ref.watch(activeOverseerrConfigProvider) != null;
});

/// Whether any download client is configured and enabled
final hasDownloadClientProvider = Provider<bool>((ref) {
  return ref.watch(activeDownloadClientConfigProvider) != null;
});

/// Count of enabled services
final enabledServicesCountProvider = Provider<int>((ref) {
  final services = ref.watch(servicesProvider);
  return services.where((s) => s.isEnabled).length;
});