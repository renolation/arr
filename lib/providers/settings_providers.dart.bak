// ========================================
// Settings Providers
// Manage app settings and service configuration UI state
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:arr/core/storage/storage_service.dart';
import 'package:arr/models/hive/service_config.dart';
import 'package:arr/models/hive/app_settings.dart';
import 'package:arr/models/hive/enums.dart';

// Storage Service
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService.instance;
});

// App Settings State

class AppSettingsState {
  final AppSettings? settings;
  final bool isLoading;
  final String? error;

  AppSettingsState({
    this.settings,
    this.isLoading = false,
    this.error,
  });

  AppSettingsState copyWith({
    AppSettings? settings,
    bool? isLoading,
    String? error,
  }) {
    return AppSettingsState(
      settings: settings ?? this.settings,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

// App Settings Notifier

class AppSettingsNotifier extends StateNotifier<AppSettingsState> {
  final StorageService _storage;

  AppSettingsNotifier(this._storage) : super(AppSettingsState()) {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    try {
      state = state.copyWith(isLoading: true);
      final settings = _storage.getSettings();
      state = state.copyWith(
        settings: settings,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> updateSettings(AppSettings newSettings) async {
    try {
      state = state.copyWith(isLoading: true);
      await _storage.saveSettings(newSettings);
      state = state.copyWith(
        settings: newSettings,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> updateThemeMode(ThemeMode mode) async {
    final current = state.settings ?? AppSettings();
    await updateSettings(current.copyWith(themeMode: mode));
  }

  Future<void> updateLocale(String locale) async {
    final current = state.settings ?? AppSettings();
    await updateSettings(current.copyWith(locale: locale));
  }

  Future<void> updateRefreshInterval(Duration interval) async {
    final current = state.settings ?? AppSettings();
    await updateSettings(current.copyWith(autoRefreshInterval: interval));
  }

  Future<void> toggleNotifications(bool enabled) async {
    final current = state.settings ?? AppSettings();
    await updateSettings(current.copyWith(notificationsEnabled: enabled));
  }
}

// Theme mode enum (matches Flutter's ThemeMode)
enum ThemeMode {
  system,
  light,
  dark,
}

// App Settings Providers

/// App settings state provider
final appSettingsProvider =
    StateNotifierProvider<AppSettingsNotifier, AppSettingsState>((ref) {
  final storage = ref.watch(storageServiceProvider);
  return AppSettingsNotifier(storage);
});

/// Current theme mode
final themeModeProvider = Provider<ThemeMode>((ref) {
  final settingsState = ref.watch(appSettingsProvider);
  return settingsState.settings?.themeMode ?? ThemeMode.system;
});

/// Current locale
final localeProvider = Provider<String>((ref) {
  final settingsState = ref.watch(appSettingsProvider);
  return settingsState.settings?.locale ?? 'en';
});

/// Auto-refresh interval
final refreshIntervalProvider = Provider<Duration>((ref) {
  final settingsState = ref.watch(appSettingsProvider);
  return settingsState.settings?.autoRefreshInterval ??
      const Duration(minutes: 30);
});

/// Notifications enabled
final notificationsEnabledProvider = Provider<bool>((ref) {
  final settingsState = ref.watch(appSettingsProvider);
  return settingsState.settings?.notificationsEnabled ?? false;
});

// Service Configuration UI State

class ServiceConfigUiState {
  final List<ServiceConfig> services;
  final ServiceConfig? editingService;
  final bool isLoading;
  final bool isTesting;
  final String? error;
  final String? successMessage;

  ServiceConfigUiState({
    this.services = const [],
    this.editingService,
    this.isLoading = false,
    this.isTesting = false,
    this.error,
    this.successMessage,
  });

  ServiceConfigUiState copyWith({
    List<ServiceConfig>? services,
    ServiceConfig? editingService,
    bool? isLoading,
    bool? isTesting,
    String? error,
    String? successMessage,
  }) {
    return ServiceConfigUiState(
      services: services ?? this.services,
      editingService: editingService ?? this.editingService,
      isLoading: isLoading ?? this.isLoading,
      isTesting: isTesting ?? this.isTesting,
      error: error,
      successMessage: successMessage,
    );
  }
}

// Service Configuration UI Notifier

class ServiceConfigUiNotifier extends StateNotifier<ServiceConfigUiState> {
  final StorageService _storage;

  ServiceConfigUiNotifier(this._storage) : super(ServiceConfigUiState()) {
    _loadServices();
  }

  void _loadServices() {
    try {
      final services = _storage.getAllServices();
      state = state.copyWith(services: services);
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  Future<void> addService(ServiceConfig service) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      await _storage.addService(service);

      _loadServices();
      state = state.copyWith(
        isLoading: false,
        successMessage: '${service.name} added successfully',
        editingService: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> updateService(ServiceConfig service) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      await _storage.updateService(service);

      _loadServices();
      state = state.copyWith(
        isLoading: false,
        successMessage: '${service.name} updated successfully',
        editingService: null,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> deleteService(ServiceConfig service) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      await _storage.deleteService(service.id);

      _loadServices();
      state = state.copyWith(
        isLoading: false,
        successMessage: '${service.name} deleted successfully',
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> testConnection(ServiceConfig service) async {
    try {
      state = state.copyWith(isTesting: true, error: null);

      // Simulate connection test
      // In real implementation, use actual API test
      await Future.delayed(const Duration(seconds: 2));

      state = state.copyWith(
        isTesting: false,
        successMessage: 'Connection to ${service.name} successful',
      );
    } catch (e) {
      state = state.copyWith(
        isTesting: false,
        error: 'Connection to ${service.name} failed: ${e.toString()}',
      );
    }
  }

  void startEditing(ServiceConfig service) {
    state = state.copyWith(editingService: service);
  }

  void stopEditing() {
    state = state.copyWith(editingService: null);
  }

  void clearMessages() {
    state = state.copyWith(
      error: null,
      successMessage: null,
    );
  }

  Future<void> setDefaultService(ServiceConfig service) async {
    try {
      // Update all services of this type to remove default flag
      final servicesOfType =
          _storage.getServicesByType(service.type);

      for (final s in servicesOfType) {
        if (s.id != service.id) {
          // Update non-default
          await _storage.updateService(s);
        }
      }

      // Set this service as default
      final updatedService = service.copyWith(
        priority: 1, // Use priority as default indicator
      );
      await _storage.updateService(updatedService);

      _loadServices();
      state = state.copyWith(
        successMessage: '${service.name} set as default',
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }
}

// Service Configuration UI Providers

/// Service configuration UI state
final serviceConfigUiProvider =
    StateNotifierProvider<ServiceConfigUiNotifier, ServiceConfigUiState>((ref) {
  final storage = ref.watch(storageServiceProvider);
  return ServiceConfigUiNotifier(storage);
});

/// Get services by type
final servicesByTypeProvider = Provider.family<List<ServiceConfig>, ServiceType>(
  (ref, type) {
    final uiState = ref.watch(serviceConfigUiProvider);
    return uiState.services.where((s) => s.type == type).toList();
  },
);

/// Get Sonarr services
final sonarrServicesProvider = Provider<List<ServiceConfig>>((ref) {
  final uiState = ref.watch(serviceConfigUiProvider);
  return uiState.services.where((s) => s.type == ServiceType.sonarr).toList();
});

/// Get Radarr services
final radarrServicesProvider = Provider<List<ServiceConfig>>((ref) {
  final uiState = ref.watch(serviceConfigUiProvider);
  return uiState.services.where((s) => s.type == ServiceType.radarr).toList();
});

/// Get Overseerr services
final overseerrServicesProvider = Provider<List<ServiceConfig>>((ref) {
  final uiState = ref.watch(serviceConfigUiProvider);
  return uiState.services
      .where((s) => s.type == ServiceType.overseerr)
      .toList();
});

/// Get download client services
final downloadClientServicesProvider = Provider<List<ServiceConfig>>((ref) {
  final uiState = ref.watch(serviceConfigUiProvider);
  return uiState.services
      .where((s) => s.type == ServiceType.downloadClient)
      .toList();
});

/// Settings page navigation state
final settingsTabProvider = StateProvider<SettingsTab>((ref) {
  return SettingsTab.general;
});

enum SettingsTab {
  general,
  services,
  appearance,
  notifications,
  about,
}
