// ========================================
// System Status Providers
// Monitor system health, disk space, and service status
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import 'package:arr/core/storage/storage_service.dart';
import 'package:arr/services/api/sonarr_api_service.dart';
import 'package:arr/services/api/radarr_api_service.dart';
import 'package:arr/models/hive/system_status.dart';
import 'package:arr/models/hive/service_config.dart';
import 'package:arr/models/hive/enums.dart';

// Storage Service
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService.instance;
});

// System Status State

class SystemStatusState {
  final Map<String, SystemStatus> statuses; // serviceId -> SystemStatus
  final bool isLoading;
  final String? error;
  final DateTime? lastUpdated;

  SystemStatusState({
    this.statuses = const {},
    this.isLoading = false,
    this.error,
    this.lastUpdated,
  });

  SystemStatusState copyWith({
    Map<String, SystemStatus>? statuses,
    bool? isLoading,
    String? error,
    DateTime? lastUpdated,
  }) {
    return SystemStatusState(
      statuses: statuses ?? this.statuses,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }

  /// Get all statuses as a list
  List<SystemStatus> get statusList => statuses.values.toList();

  /// Get all healthy statuses
  List<SystemStatus> get healthyStatuses =>
      statusList.where((s) => s.isHealthy).toList();

  /// Get all unhealthy statuses
  List<SystemStatus> get unhealthyStatuses =>
      statusList.where((s) => !s.isHealthy).toList();

  /// Get all critical issues
  List<HealthIssue> get allCriticalIssues => statusList
      .expand((s) => s.criticalIssues)
      .toList();

  /// Get all warning issues
  List<HealthIssue> get allWarningIssues => statusList
      .expand((s) => s.warningIssues)
      .toList();
}

// System Status Notifier

class SystemStatusNotifier extends StateNotifier<SystemStatusState> {
  final StorageService _storage;
  final Ref _ref;

  SystemStatusNotifier(this._storage, this._ref)
      : super(SystemStatusState()) {
    _loadStatuses();
  }

  Future<void> _loadStatuses() async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      // Load cached statuses from Hive
      final cachedStatuses = _storage.getAllSystemStatuses();
      final statusMap = <String, SystemStatus>{};
      for (final status in cachedStatuses) {
        statusMap[status.serviceId] = status;
      }

      state = state.copyWith(
        statuses: statusMap,
        isLoading: false,
        lastUpdated: DateTime.now(),
      );

      // Trigger refresh in background
      refresh();
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> refresh() async {
    final services = _storage.getEnabledServices();

    for (final service in services) {
      await _refreshServiceStatus(service);
    }
  }

  Future<void> _refreshServiceStatus(ServiceConfig service) async {
    try {
      SystemStatus? status;

      switch (service.type) {
        case ServiceType.sonarr:
          final sonarrApi = _ref.read(sonarrApiServiceProvider);
          if (sonarrApi != null) {
            status = await _fetchSonarrStatus(service, sonarrApi);
          }
          break;

        case ServiceType.radarr:
          final radarrApi = _ref.read(radarrApiServiceProvider);
          if (radarrApi != null) {
            status = await _fetchRadarrStatus(service, radarrApi);
          }
          break;

        default:
          // Other service types can be added here
          break;
      }

      if (status != null) {
        await _storage.updateSystemStatus(status);

        final newStatuses = Map<String, SystemStatus>.from(state.statuses);
        newStatuses[service.id] = status;

        state = state.copyWith(statuses: newStatuses);
      }
    } catch (e) {
      // Log error but continue with other services
      print('Error refreshing status for ${service.name}: $e');
    }
  }

  Future<SystemStatus> _fetchSonarrStatus(
    ServiceConfig service,
    SonarrApiService api,
  ) async {
    final response = await api.getSystemStatus();
    final data = response.data;

    return SystemStatus(
      serviceId: service.id,
      version: data['version'] as String?,
      appName: 'Sonarr',
      status: 'ok',
      timestamp: DateTime.now(),
    );
  }

  Future<SystemStatus> _fetchRadarrStatus(
    ServiceConfig service,
    RadarrApiService api,
  ) async {
    final response = await api.getSystemStatus();
    final data = response.data;

    return SystemStatus(
      serviceId: service.id,
      version: data['version'] as String?,
      appName: 'Radarr',
      status: 'ok',
      timestamp: DateTime.now(),
    );
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// System Status Providers

/// System status state provider
final systemStatusProvider =
    StateNotifierProvider<SystemStatusNotifier, SystemStatusState>((ref) {
  final storage = ref.watch(storageServiceProvider);
  return SystemStatusNotifier(storage, ref);
});

/// System status for a specific service
final serviceStatusProvider =
    Provider.family<SystemStatus?, String>((ref, serviceId) {
  final state = ref.watch(systemStatusProvider);
  return state.statuses[serviceId];
});

/// Overall system health (true if all services are healthy)
final systemHealthProvider = Provider<bool>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statuses.values.every((s) => s.isHealthy) ||
      state.statuses.isEmpty;
});

/// Count of critical health issues
final criticalIssuesCountProvider = Provider<int>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.allCriticalIssues.length;
});

/// Count of warning health issues
final warningIssuesCountProvider = Provider<int>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.allWarningIssues.length;
});

/// Combined download speed across all services
final totalDownloadSpeedProvider = Provider<double>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statusList.fold(
    0.0,
    (sum, status) => sum + (status.downloadSpeed ?? 0.0),
  );
});

/// Combined upload speed across all services
final totalUploadSpeedProvider = Provider<double>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statusList.fold(
    0.0,
    (sum, status) => sum + (status.uploadSpeed ?? 0.0),
  );
});

/// Total queue size across all services
final totalQueueSizeProvider = Provider<int>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statusList.fold(
    0,
    (sum, status) => sum + (status.queueSize ?? 0),
  );
});

/// Missing items count across all services
final totalMissingItemsProvider = Provider<int>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statusList.fold(
    0,
    (sum, status) =>
        sum + (status.missingMovies ?? 0) + (status.missingEpisodes ?? 0),
  );
});

// Disk Space Providers

/// All disk space information
final diskSpaceProvider = Provider<List<DiskSpaceInfo>>((ref) {
  final state = ref.watch(systemStatusProvider);
  return state.statusList
      .map((s) => s.diskSpace)
      .whereType<DiskSpaceInfo>()
      .toList();
});

/// Total disk space used across all services
final totalDiskSpaceProvider = Provider<DiskSpaceSummary>((ref) {
  final diskSpaces = ref.watch(diskSpaceProvider);

  final totalFree = diskSpaces.fold<double>(
    0,
    (sum, ds) => sum + (ds.free ?? 0),
  );

  final totalCapacity = diskSpaces.fold<double>(
    0,
    (sum, ds) => sum + (ds.total ?? 0),
  );

  final totalUsed = totalCapacity - totalFree;
  final usagePercentage =
      totalCapacity > 0 ? (totalUsed / totalCapacity) * 100 : 0;

  return DiskSpaceSummary(
    totalFree: totalFree,
    totalCapacity: totalCapacity,
    totalUsed: totalUsed,
    usagePercentage: usagePercentage,
  );
});

// Disk Space Summary Class
class DiskSpaceSummary {
  final double totalFree;
  final double totalCapacity;
  final double totalUsed;
  final double usagePercentage;

  DiskSpaceSummary({
    required this.totalFree,
    required this.totalCapacity,
    required this.totalUsed,
    required this.usagePercentage,
  });

  String get formattedFree => '${totalFree.toStringAsFixed(2)} GB';
  String get formattedCapacity => '${totalCapacity.toStringAsFixed(2)} GB';
  String get formattedUsed => '${totalUsed.toStringAsFixed(2)} GB';
  String get formattedPercentage => '${usagePercentage.toStringAsFixed(1)}%';
}

// Overview Statistics Provider

/// Combined overview statistics for dashboard
final overviewStatsProvider = Provider<OverviewStatistics>((ref) {
  final systemHealth = ref.watch(systemHealthProvider);
  final criticalIssues = ref.watch(criticalIssuesCountProvider);
  final warningIssues = ref.watch(warningIssuesCountProvider);
  final downloadSpeed = ref.watch(totalDownloadSpeedProvider);
  final uploadSpeed = ref.watch(totalUploadSpeedProvider);
  final queueSize = ref.watch(totalQueueSizeProvider);
  final missingItems = ref.watch(totalMissingItemsProvider);
  final diskSpace = ref.watch(totalDiskSpaceProvider);

  return OverviewStatistics(
    isHealthy: systemHealth,
    criticalIssuesCount: criticalIssues,
    warningIssuesCount: warningIssues,
    downloadSpeed: downloadSpeed,
    uploadSpeed: uploadSpeed,
    queueSize: queueSize,
    missingItems: missingItems,
    diskSpaceUsage: diskSpace.usagePercentage,
    diskSpaceFree: diskSpace.totalFree,
    diskSpaceTotal: diskSpace.totalCapacity,
  );
});

// Overview Statistics Class
class OverviewStatistics {
  final bool isHealthy;
  final int criticalIssuesCount;
  final int warningIssuesCount;
  final double downloadSpeed;
  final double uploadSpeed;
  final int queueSize;
  final int missingItems;
  final double diskSpaceUsage;
  final double diskSpaceFree;
  final double diskSpaceTotal;

  OverviewStatistics({
    required this.isHealthy,
    required this.criticalIssuesCount,
    required this.warningIssuesCount,
    required this.downloadSpeed,
    required this.uploadSpeed,
    required this.queueSize,
    required this.missingItems,
    required this.diskSpaceUsage,
    required this.diskSpaceFree,
    required this.diskSpaceTotal,
  });

  String get formattedDownloadSpeed =>
      '${downloadSpeed.toStringAsFixed(2)} MB/s';
  String get formattedUploadSpeed => '${uploadSpeed.toStringAsFixed(2)} MB/s';
  String get formattedDiskUsage => '${diskSpaceUsage.toStringAsFixed(1)}%';
  String get formattedDiskFree => '${diskSpaceFree.toStringAsFixed(2)} GB';
  String get formattedDiskTotal => '${diskSpaceTotal.toStringAsFixed(2)} GB';

  bool get hasIssues => criticalIssuesCount > 0 || warningIssuesCount > 0;
}
