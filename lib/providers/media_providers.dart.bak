// ========================================
// Media Providers
// Unified state management for browsing movies and TV series
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:arr/core/storage/storage_service.dart';
import 'package:arr/models/hive/media_item.dart';
import 'package:arr/models/hive/series_hive.dart';
import 'package:arr/models/hive/movie_hive.dart';
import 'package:arr/models/hive/episode_hive.dart';
import 'package:arr/models/hive/enums.dart';

// Unified Media State

class MediaState {
  final List<MediaItem> items;
  final bool isLoading;
  final String? error;
  final DateTime? lastUpdated;

  MediaState({
    this.items = const [],
    this.isLoading = false,
    this.error,
    this.lastUpdated,
  });

  MediaState copyWith({
    List<MediaItem>? items,
    bool? isLoading,
    String? error,
    DateTime? lastUpdated,
  }) {
    return MediaState(
      items: items ?? this.items,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      lastUpdated: lastUpdated ?? this.lastUpdated,
    );
  }
}

// Unified Media Notifier

class MediaNotifier extends StateNotifier<MediaState> {
  final StorageService _storage;

  MediaNotifier(this._storage) : super(MediaState()) {
    _loadMedia();
  }

  Future<void> _loadMedia() async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      // Load all media items from unified box
      final items = _storage.getAllMedia();

      // Sort by title
      items.sort((a, b) => (a.sortTitle ?? a.title)
          .toLowerCase()
          .compareTo((b.sortTitle ?? b.title).toLowerCase()));

      state = state.copyWith(
        items: items,
        isLoading: false,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> refresh() async {
    await _loadMedia();
  }

  Future<void> filterByType(MediaType? type) async {
    try {
      state = state.copyWith(isLoading: true);

      final allItems = _storage.getAllMedia();
      final filtered = type == null
          ? allItems
          : allItems.where((item) => item.type == type).toList();

      filtered.sort((a, b) => (a.sortTitle ?? a.title)
          .toLowerCase()
          .compareTo((b.sortTitle ?? b.title).toLowerCase()));

      state = state.copyWith(
        items: filtered,
        isLoading: false,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> filterByService(String serviceId) async {
    try {
      state = state.copyWith(isLoading: true);

      final items = _storage.getMediaByService(serviceId);

      state = state.copyWith(
        items: items,
        isLoading: false,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> search(String query) async {
    try {
      state = state.copyWith(isLoading: true);

      if (query.isEmpty) {
        await _loadMedia();
        return;
      }

      final items = _storage.searchMedia(query);

      state = state.copyWith(
        items: items,
        isLoading: false,
        lastUpdated: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// Media Providers

/// Storage service dependency
final storageServiceProvider = Provider<StorageService>((ref) {
  return StorageService.instance;
});

/// Unified media state provider
final mediaProvider = StateNotifierProvider<MediaNotifier, MediaState>((ref) {
  final storage = ref.watch(storageServiceProvider);
  return MediaNotifier(storage);
});

/// Media filter type (all, movies, series)
final mediaFilterProvider = StateProvider<MediaFilter>((ref) {
  return MediaFilter.all;
});

enum MediaFilter {
  all,
  movies,
  series,
}

/// Search query for media
final mediaSearchProvider = StateProvider<String>((ref) => '');

/// Filtered media based on current filter and search
final filteredMediaProvider = Provider<List<MediaItem>>((ref) {
  final mediaState = ref.watch(mediaProvider);
  final filter = ref.watch(mediaFilterProvider);
  final searchQuery = ref.watch(mediaSearchProvider).toLowerCase();

  var items = mediaState.items;

  // Apply type filter
  if (filter != MediaFilter.all) {
    items = items.where((item) {
      if (filter == MediaFilter.movies) return item.type == MediaType.movie;
      if (filter == MediaFilter.series) return item.type == MediaType.series;
      return true;
    }).toList();
  }

  // Apply search filter
  if (searchQuery.isNotEmpty) {
    items = items.where((item) {
      final title = item.title.toLowerCase();
      final sortTitle = item.sortTitle?.toLowerCase() ?? '';
      final overview = item.overview?.toLowerCase() ?? '';
      final year = item.year?.toString() ?? '';

      return title.contains(searchQuery) ||
          sortTitle.contains(searchQuery) ||
          overview.contains(searchQuery) ||
          year.contains(searchQuery);
    }).toList();
  }

  return items;
});

/// Movies only provider
final moviesProvider = Provider<List<MediaItem>>((ref) {
  final allMedia = ref.watch(filteredMediaProvider);
  return allMedia.where((item) => item.type == MediaType.movie).toList();
});

/// Series only provider
final seriesProvider = Provider<List<MediaItem>>((ref) {
  final allMedia = ref.watch(filteredMediaProvider);
  return allMedia.where((item) => item.type == MediaType.series).toList();
});

// Media Statistics Providers

/// Overall media statistics
final mediaStatsProvider = Provider<MediaStatistics>((ref) {
  final mediaState = ref.watch(mediaProvider);
  final items = mediaState.items;

  final movies = items.where((item) => item.type == MediaType.movie).toList();
  final series = items.where((item) => item.type == MediaType.series).toList();

  final monitoredMovies = movies.where((m) => m.monitored == true).length;
  final monitoredSeries = series.where((s) => s.monitored == true).length;

  final totalSize = items.fold<int>(
    0,
    (sum, item) => sum + (item.sizeOnDisk ?? 0),
  );

  return MediaStatistics(
    totalMovies: movies.length,
    totalSeries: series.length,
    monitoredMovies: monitoredMovies,
    monitoredSeries: monitoredSeries,
    totalSizeBytes: totalSize,
  );
});

/// Movie-specific statistics
final movieStatsProvider = Provider<MovieStatistics>((ref) {
  final movies = ref.watch(moviesProvider);

  final monitored = movies.where((m) => m.monitored == true).length;
  final downloaded =
      movies.where((m) => m.status == MediaStatus.completed).length;
  final missing =
      movies.where((m) => m.status == MediaStatus.missing).length;

  final totalSize =
      movies.fold<int>(0, (sum, m) => sum + (m.sizeOnDisk ?? 0));

  return MovieStatistics(
    total: movies.length,
    monitored: monitored,
    downloaded: downloaded,
    missing: missing,
    totalSizeBytes: totalSize,
  );
});

/// Series-specific statistics
final seriesStatsProvider = Provider<SeriesStatistics>((ref) {
  final series = ref.watch(seriesProvider);

  final monitored = series.where((s) => s.monitored == true).length;
  final continuing =
      series.where((s) => s.status == MediaStatus.continuing).length;
  final ended = series.where((s) => s.status == MediaStatus.ended).length;

  final totalSize =
      series.fold<int>(0, (sum, s) => sum + (s.sizeOnDisk ?? 0));

  return SeriesStatistics(
    total: series.length,
    monitored: monitored,
    continuing: continuing,
    ended: ended,
    totalSizeBytes: totalSize,
  );
});

// Media Statistics Classes

class MediaStatistics {
  final int totalMovies;
  final int totalSeries;
  final int monitoredMovies;
  final int monitoredSeries;
  final int totalSizeBytes;

  MediaStatistics({
    required this.totalMovies,
    required this.totalSeries,
    required this.monitoredMovies,
    required this.monitoredSeries,
    required this.totalSizeBytes,
  });

  int get totalItems => totalMovies + totalSeries;
  String get formattedTotalSize {
    if (totalSizeBytes < 1024 * 1024) {
      return '${(totalSizeBytes / 1024).toStringAsFixed(2)} KB';
    }
    if (totalSizeBytes < 1024 * 1024 * 1024) {
      return '${(totalSizeBytes / (1024 * 1024)).toStringAsFixed(2)} MB';
    }
    return '${(totalSizeBytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }
}

class MovieStatistics {
  final int total;
  final int monitored;
  final int downloaded;
  final int missing;
  final int totalSizeBytes;

  MovieStatistics({
    required this.total,
    required this.monitored,
    required this.downloaded,
    required this.missing,
    required this.totalSizeBytes,
  });

  double get downloadPercentage =>
      total > 0 ? (downloaded / total) * 100 : 0;
  String get formattedTotalSize {
    if (totalSizeBytes < 1024 * 1024 * 1024) {
      return '${(totalSizeBytes / (1024 * 1024)).toStringAsFixed(2)} MB';
    }
    return '${(totalSizeBytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }
}

class SeriesStatistics {
  final int total;
  final int monitored;
  final int continuing;
  final int ended;
  final int totalSizeBytes;

  SeriesStatistics({
    required this.total,
    required this.monitored,
    required this.continuing,
    required this.ended,
    required this.totalSizeBytes,
  });

  String get formattedTotalSize {
    if (totalSizeBytes < 1024 * 1024 * 1024) {
      return '${(totalSizeBytes / (1024 * 1024)).toStringAsFixed(2)} MB';
    }
    return '${(totalSizeBytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }
}

// Media Item Detail Providers

/// Get a specific media item by ID
final mediaItemProvider = FutureProvider.family<MediaItem?, String>((ref, id) async {
  final storage = ref.watch(storageServiceProvider);
  return storage.getMediaItem(id);
});

/// Get series detail from series box
final seriesDetailProvider =
    FutureProvider.family<SeriesHive?, int>((ref, seriesId) async {
  final storage = ref.watch(storageServiceProvider);
  return storage.getSeries(seriesId);
});

/// Get movie detail from movie box
final movieDetailProvider =
    FutureProvider.family<MovieHive?, int>((ref, movieId) async {
  final storage = ref.watch(storageServiceProvider);
  return storage.getMovie(movieId);
});

/// Get episodes for a series
final seriesEpisodesProvider =
    FutureProvider.family<List<EpisodeHive>, int>((ref, seriesId) async {
  final storage = ref.watch(storageServiceProvider);
  return storage.getEpisodesBySeries(seriesId);
});
