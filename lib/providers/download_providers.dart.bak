// ========================================
// Download Queue Providers
// Monitor download queue and activity
// ========================================

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:async/async.dart';
import 'package:arr/services/api/sonarr_api_service.dart';
import 'package:arr/services/api/radarr_api_service.dart';
import 'package:arr/providers/service_providers.dart';

// Download Queue Item Model

class QueueItem {
  final String id;
  final String title;
  final String? serviceId;
  final String? serviceType;
  final double size;
  final double sizeLeft;
  final double progress; // 0.0 to 1.0
  final String status;
  final String? errorMessage;
  final DateTime? timeLeft;
  final double downloadSpeed;
  final double uploadSpeed;
  final DateTime? added;
  final String? quality;

  QueueItem({
    required this.id,
    required this.title,
    this.serviceId,
    this.serviceType,
    required this.size,
    required this.sizeLeft,
    required this.progress,
    required this.status,
    this.errorMessage,
    this.timeLeft,
    required this.downloadSpeed,
    required this.uploadSpeed,
    this.added,
    this.quality,
  });

  /// Get formatted size (e.g., "1.5 GB")
  String get formattedSize {
    if (size < 1024 * 1024) {
      return '${(size / 1024).toStringAsFixed(2)} MB';
    }
    return '${(size / (1024 * 1024)).toStringAsFixed(2)} GB';
  }

  /// Get formatted size left (e.g., "500 MB")
  String get formattedSizeLeft {
    if (sizeLeft < 1024 * 1024) {
      return '${(sizeLeft / 1024).toStringAsFixed(2)} MB';
    }
    return '${(sizeLeft / (1024 * 1024)).toStringAsFixed(2)} GB';
  }

  /// Get formatted progress percentage (e.g., "75%")
  String get formattedProgress => '${(progress * 100).toStringAsFixed(1)}%';

  /// Get formatted time left (e.g., "5m 30s")
  String? get formattedTimeLeft {
    if (timeLeft == null) return null;
    final duration = DateTime.now().difference(timeLeft!);
    if (duration.isNegative) {
      final remaining = duration.abs();
      if (remaining.inHours > 0) {
        return '${remaining.inHours}h ${remaining.inMinutes % 60}m';
      } else if (remaining.inMinutes > 0) {
        return '${remaining.inMinutes}m ${remaining.inSeconds % 60}s';
      } else {
        return '${remaining.inSeconds}s';
      }
    }
    return 'Soon';
  }

  /// Get formatted download speed (e.g., "5.5 MB/s")
  String get formattedDownloadSpeed {
    if (downloadSpeed < 1024 * 1024) {
      return '${(downloadSpeed / 1024).toStringAsFixed(2)} MB/s';
    }
    return '${(downloadSpeed / (1024 * 1024)).toStringAsFixed(2)} GB/s';
  }

  /// Get formatted upload speed (e.g., "1.2 MB/s")
  String get formattedUploadSpeed {
    if (uploadSpeed < 1024 * 1024) {
      return '${(uploadSpeed / 1024).toStringAsFixed(2)} MB/s';
    }
    return '${(uploadSpeed / (1024 * 1024)).toStringAsFixed(2)} GB/s';
  }

  /// Check if download is active (downloading or queued)
  bool get isActive =>
      status == 'downloading' ||
      status == 'queued' ||
      status == 'paused';

  /// Check if download is complete
  bool get isComplete => status == 'completed';

  /// Check if download has failed
  bool get hasFailed => status == 'failed' || status == 'warning';

  /// Check if download is paused
  bool get isPaused => status == 'paused';

  QueueItem copyWith({
    String? id,
    String? title,
    String? serviceId,
    String? serviceType,
    double? size,
    double? sizeLeft,
    double? progress,
    String? status,
    String? errorMessage,
    DateTime? timeLeft,
    double? downloadSpeed,
    double? uploadSpeed,
    DateTime? added,
    String? quality,
  }) {
    return QueueItem(
      id: id ?? this.id,
      title: title ?? this.title,
      serviceId: serviceId ?? this.serviceId,
      serviceType: serviceType ?? this.serviceType,
      size: size ?? this.size,
      sizeLeft: sizeLeft ?? this.sizeLeft,
      progress: progress ?? this.progress,
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
      timeLeft: timeLeft ?? this.timeLeft,
      downloadSpeed: downloadSpeed ?? this.downloadSpeed,
      uploadSpeed: uploadSpeed ?? this.uploadSpeed,
      added: added ?? this.added,
      quality: quality ?? this.quality,
    );
  }
}

// Download Queue State

class DownloadQueueState {
  final List<QueueItem> items;
  final bool isLoading;
  final String? error;
  final DateTime? lastUpdated;
  final int totalActive;
  final int totalCompleted;
  final int totalFailed;
  final double totalDownloadSpeed;
  final double totalUploadSpeed;

  DownloadQueueState({
    this.items = const [],
    this.isLoading = false,
    this.error,
    this.lastUpdated,
    this.totalActive = 0,
    this.totalCompleted = 0,
    this.totalFailed = 0,
    this.totalDownloadSpeed = 0.0,
    this.totalUploadSpeed = 0.0,
  });

  DownloadQueueState copyWith({
    List<QueueItem>? items,
    bool? isLoading,
    String? error,
    DateTime? lastUpdated,
    int? totalActive,
    int? totalCompleted,
    int? totalFailed,
    double? totalDownloadSpeed,
    double? totalUploadSpeed,
  }) {
    return DownloadQueueState(
      items: items ?? this.items,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      lastUpdated: lastUpdated ?? this.lastUpdated,
      totalActive: totalActive ?? this.totalActive,
      totalCompleted: totalCompleted ?? this.totalCompleted,
      totalFailed: totalFailed ?? this.totalFailed,
      totalDownloadSpeed: totalDownloadSpeed ?? this.totalDownloadSpeed,
      totalUploadSpeed: totalUploadSpeed ?? this.totalUploadSpeed,
    );
  }

  /// Get active downloads
  List<QueueItem> get activeDownloads =>
      items.where((item) => item.isActive).toList();

  /// Get completed downloads
  List<QueueItem> get completedDownloads =>
      items.where((item) => item.isComplete).toList();

  /// Get failed downloads
  List<QueueItem> get failedDownloads =>
      items.where((item) => item.hasFailed).toList();

  /// Get paused downloads
  List<QueueItem> get pausedDownloads =>
      items.where((item) => item.isPaused).toList();
}

// Download Queue Notifier

class DownloadQueueNotifier extends StateNotifier<DownloadQueueState> {
  final Ref _ref;
  RestartableTimer? _refreshTimer;

  DownloadQueueNotifier(this._ref) : super(DownloadQueueState()) {
    _startAutoRefresh();
    refresh();
  }

  void _startAutoRefresh() {
    // Refresh every 10 seconds
    _refreshTimer = RestartableTimer(
      const Duration(seconds: 10),
      () => refresh(),
    );
  }

  @override
  void dispose() {
    _refreshTimer?.cancel();
    super.dispose();
  }

  Future<void> refresh() async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final items = <QueueItem>[];

      // Fetch Sonarr queue
      final sonarrApi = _ref.read(sonarrApiServiceProvider);
      if (sonarrApi != null) {
        try {
          final sonarrQueue = await sonarrApi.getQueue();
          final sonarrItems = _parseSonarrQueue(
            sonarrQueue.data,
            'sonarr',
          );
          items.addAll(sonarrItems);
        } catch (e) {
          print('Error fetching Sonarr queue: $e');
        }
      }

      // Fetch Radarr queue
      final radarrApi = _ref.read(radarrApiServiceProvider);
      if (radarrApi != null) {
        try {
          final radarrQueue = await radarrApi.getQueue();
          final radarrItems = _parseRadarrQueue(
            radarrQueue.data,
            'radarr',
          );
          items.addAll(radarrItems);
        } catch (e) {
          print('Error fetching Radarr queue: $e');
        }
      }

      // Calculate statistics
      final totalActive = items.where((i) => i.isActive).length;
      final totalCompleted = items.where((i) => i.isComplete).length;
      final totalFailed = items.where((i) => i.hasFailed).length;
      final totalDownloadSpeed = items.fold<double>(
        0.0,
        (sum, item) => sum + item.downloadSpeed,
      );
      final totalUploadSpeed = items.fold<double>(
        0.0,
        (sum, item) => sum + item.uploadSpeed,
      );

      state = state.copyWith(
        items: items,
        isLoading: false,
        lastUpdated: DateTime.now(),
        totalActive: totalActive,
        totalCompleted: totalCompleted,
        totalFailed: totalFailed,
        totalDownloadSpeed: totalDownloadSpeed,
        totalUploadSpeed: totalUploadSpeed,
      );

      // Reset timer
      _refreshTimer?.reset();
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      _refreshTimer?.reset();
    }
  }

  List<QueueItem> _parseSonarrQueue(
    dynamic data,
    String serviceType,
  ) {
    final items = <QueueItem>[];

    if (data == null || data is! Map) return items;

    final records = data['records'] as List<dynamic>?;
    if (records == null) return items;

    for (final record in records) {
      if (record is! Map) continue;

      try {
        final item = QueueItem(
          id: record['downloadId']?.toString() ?? '',
          title: record['series']?['title']?.toString() ?? 'Unknown',
          serviceType: serviceType,
          size: (record['size'] as num?)?.toDouble() ?? 0.0,
          sizeLeft: (record['sizeleft'] as num?)?.toDouble() ?? 0.0,
          progress: (record['sizeleft'] != null && record['size'] != null)
              ? 1.0 - ((record['sizeleft'] as num) / (record['size'] as num))
              : 0.0,
          status: record['status']?.toString() ?? 'unknown',
          errorMessage: record['errorMessage']?.toString(),
          downloadSpeed: (record['downloadSpeed'] as num?)?.toDouble() ?? 0.0,
          uploadSpeed: (record['uploadSpeed'] as num?)?.toDouble() ?? 0.0,
          added: record['added'] != null
              ? DateTime.tryParse(record['added'].toString())
              : null,
          quality: record['quality']?['quality']?['name']?.toString(),
        );

        items.add(item);
      } catch (e) {
        print('Error parsing Sonarr queue item: $e');
      }
    }

    return items;
  }

  List<QueueItem> _parseRadarrQueue(
    dynamic data,
    String serviceType,
  ) {
    final items = <QueueItem>[];

    if (data == null || data is! Map) return items;

    final records = data['records'] as List<dynamic>?;
    if (records == null) return items;

    for (final record in records) {
      if (record is! Map) continue;

      try {
        final item = QueueItem(
          id: record['downloadId']?.toString() ?? '',
          title: record['movie']?['title']?.toString() ?? 'Unknown',
          serviceType: serviceType,
          size: (record['size'] as num?)?.toDouble() ?? 0.0,
          sizeLeft: (record['sizeleft'] as num?)?.toDouble() ?? 0.0,
          progress: (record['sizeleft'] != null && record['size'] != null)
              ? 1.0 - ((record['sizeleft'] as num) / (record['size'] as num))
              : 0.0,
          status: record['status']?.toString() ?? 'unknown',
          errorMessage: record['errorMessage']?.toString(),
          downloadSpeed: (record['downloadSpeed'] as num?)?.toDouble() ?? 0.0,
          uploadSpeed: (record['uploadSpeed'] as num?)?.toDouble() ?? 0.0,
          added: record['added'] != null
              ? DateTime.tryParse(record['added'].toString())
              : null,
          quality: record['quality']?['quality']?['name']?.toString(),
        );

        items.add(item);
      } catch (e) {
        print('Error parsing Radarr queue item: $e');
      }
    }

    return items;
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// Download Queue Providers

/// Download queue state provider
final downloadQueueProvider =
    StateNotifierProvider<DownloadQueueNotifier, DownloadQueueState>((ref) {
  return DownloadQueueNotifier(ref);
});

/// Active downloads only
final activeDownloadsProvider = Provider<List<QueueItem>>((ref) {
  final queueState = ref.watch(downloadQueueProvider);
  return queueState.activeDownloads;
});

/// Completed downloads only
final completedDownloadsProvider = Provider<List<QueueItem>>((ref) {
  final queueState = ref.watch(downloadQueueProvider);
  return queueState.completedDownloads;
});

/// Failed downloads only
final failedDownloadsProvider = Provider<List<QueueItem>>((ref) {
  final queueState = ref.watch(downloadQueueProvider);
  return queueState.failedDownloads;
});

/// Download queue statistics
final downloadStatsProvider = Provider<DownloadStatistics>((ref) {
  final queueState = ref.watch(downloadQueueProvider);

  return DownloadStatistics(
    totalItems: queueState.items.length,
    activeCount: queueState.totalActive,
    completedCount: queueState.totalCompleted,
    failedCount: queueState.totalFailed,
    downloadSpeed: queueState.totalDownloadSpeed,
    uploadSpeed: queueState.totalUploadSpeed,
  );
});

/// Download statistics model
class DownloadStatistics {
  final int totalItems;
  final int activeCount;
  final int completedCount;
  final int failedCount;
  final double downloadSpeed;
  final double uploadSpeed;

  DownloadStatistics({
    required this.totalItems,
    required this.activeCount,
    required this.completedCount,
    required this.failedCount,
    required this.downloadSpeed,
    required this.uploadSpeed,
  });

  String get formattedDownloadSpeed {
    if (downloadSpeed < 1024 * 1024) {
      return '${(downloadSpeed / 1024).toStringAsFixed(2)} MB/s';
    }
    return '${(downloadSpeed / (1024 * 1024)).toStringAsFixed(2)} GB/s';
  }

  String get formattedUploadSpeed {
    if (uploadSpeed < 1024 * 1024) {
      return '${(uploadSpeed / 1024).toStringAsFixed(2)} MB/s';
    }
    return '${(uploadSpeed / (1024 * 1024)).toStringAsFixed(2)} GB/s';
  }
}

/// Stream for real-time download progress updates
final downloadStreamProvider = StreamProvider<List<QueueItem>>((ref) {
  // Create a stream that emits the queue every 10 seconds
  return Stream.periodic(
    const Duration(seconds: 10),
    (_) => ref.read(downloadQueueProvider).items,
  );
});
